{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Dylan Karrass\\\\Desktop\\\\harmonize\\\\client\\\\src\\\\MessageContext.js\",\n  _s = $RefreshSig$();\n// Import necessary React utilities and Socket.IO client for real-time communication.\nimport React, { createContext, useState, useEffect } from 'react';\nimport io from 'socket.io-client';\n\n// Create a context that will be used to provide and consume the message-related data.\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const MessageContext = /*#__PURE__*/createContext();\nexport const MessageProvider = ({\n  children\n}) => {\n  _s();\n  // State for managing the current active conversation.\n  const [currentConversation, setCurrentConversation] = useState(null);\n  // State to store a list of all conversations related to the user.\n  const [conversations, setConversations] = useState([]);\n  // Establish a socket connection to the server.\n  const socket = io('http://localhost:8888');\n\n  // Effect hook to handle incoming messages via WebSocket.\n  useEffect(() => {\n    socket.on('receiveMessage', message => {\n      // Update the current conversation with the new message if the message belongs to it.\n      if (currentConversation && message.conversationId === currentConversation._id) {\n        setCurrentConversation(prev => ({\n          ...prev,\n          messages: [...prev.messages, message]\n        }));\n      }\n      // Update the list of conversations when a new message is received.\n      setConversations(prev => prev.map(convo => {\n        if (convo._id === message.conversationId) {\n          // Update last message for the conversation list.\n          return {\n            ...convo,\n            lastMessage: message\n          }; // Adjust based on your data structure.\n        }\n        return convo;\n      }));\n    });\n\n    // Clean up by removing the event listener when the component unmounts.\n    return () => {\n      socket.off('receiveMessage');\n    };\n  }, [currentConversation, conversations]);\n\n  // Function to send a message using the socket.\n  const sendMessage = ({\n    message,\n    to\n  }) => {\n    socket.emit('sendMessage', {\n      message,\n      to,\n      conversationId: to\n    });\n  };\n\n  // Function to fetch a specific conversation by ID.\n  const fetchConversation = conversationId => {\n    fetch(`http://localhost:8888/api/conversations/${conversationId}`).then(response => response.json()).then(data => {\n      setCurrentConversation(data);\n    }).catch(error => {\n      console.error('Failed to fetch conversation:', error);\n    });\n  };\n\n  // Function to fetch all conversations for a specific user.\n  const fetchConversations = userId => {\n    fetch(`http://localhost:8888/api/conversations/user/${userId}`).then(response => response.json()).then(data => {\n      setConversations(data);\n    }).catch(error => {\n      console.error('Failed to fetch conversations:', error);\n      setConversations([]); // Reset to empty array on error to clear previous state.\n    });\n  };\n\n  // Render the provider with its value containing state and functions that can be accessed by consumer components.\n  return /*#__PURE__*/_jsxDEV(MessageContext.Provider, {\n    value: {\n      currentConversation,\n      fetchConversation,\n      sendMessage,\n      setCurrentConversation,\n      conversations,\n      // Make conversations list available.\n      fetchConversations,\n      // Make method to fetch conversations available.\n      setConversations // Make setter function for conversations available.\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 74,\n    columnNumber: 9\n  }, this) // Render children within the provider to allow access to the context.\n  ;\n};\n_s(MessageProvider, \"NGxz29DjmslwiW3WOlMmbZfhg+w=\");\n_c = MessageProvider;\nvar _c;\n$RefreshReg$(_c, \"MessageProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","io","jsxDEV","_jsxDEV","MessageContext","MessageProvider","children","_s","currentConversation","setCurrentConversation","conversations","setConversations","socket","on","message","conversationId","_id","prev","messages","map","convo","lastMessage","off","sendMessage","to","emit","fetchConversation","fetch","then","response","json","data","catch","error","console","fetchConversations","userId","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Dylan Karrass/Desktop/harmonize/client/src/MessageContext.js"],"sourcesContent":["// Import necessary React utilities and Socket.IO client for real-time communication.\r\nimport React, { createContext, useState, useEffect } from 'react';\r\nimport io from 'socket.io-client';\r\n\r\n// Create a context that will be used to provide and consume the message-related data.\r\nexport const MessageContext = createContext();\r\n\r\nexport const MessageProvider = ({ children }) => {\r\n    // State for managing the current active conversation.\r\n    const [currentConversation, setCurrentConversation] = useState(null);\r\n    // State to store a list of all conversations related to the user.\r\n    const [conversations, setConversations] = useState([]);\r\n    // Establish a socket connection to the server.\r\n    const socket = io('http://localhost:8888');\r\n\r\n    // Effect hook to handle incoming messages via WebSocket.\r\n    useEffect(() => {\r\n        socket.on('receiveMessage', (message) => {\r\n            // Update the current conversation with the new message if the message belongs to it.\r\n            if (currentConversation && message.conversationId === currentConversation._id) {\r\n                setCurrentConversation(prev => ({\r\n                    ...prev,\r\n                    messages: [...prev.messages, message]\r\n                }));\r\n            }\r\n            // Update the list of conversations when a new message is received.\r\n            setConversations(prev => prev.map(convo => {\r\n                if (convo._id === message.conversationId) {\r\n                    // Update last message for the conversation list.\r\n                    return { ...convo, lastMessage: message };  // Adjust based on your data structure.\r\n                }\r\n                return convo;\r\n            }));\r\n        });\r\n\r\n        // Clean up by removing the event listener when the component unmounts.\r\n        return () => {\r\n            socket.off('receiveMessage');\r\n        };\r\n    }, [currentConversation, conversations]);\r\n\r\n    // Function to send a message using the socket.\r\n    const sendMessage = ({ message, to }) => {\r\n        socket.emit('sendMessage', { message, to, conversationId: to });\r\n    };\r\n\r\n    // Function to fetch a specific conversation by ID.\r\n    const fetchConversation = (conversationId) => {\r\n        fetch(`http://localhost:8888/api/conversations/${conversationId}`)\r\n            .then(response => response.json())\r\n            .then(data => {\r\n                setCurrentConversation(data);\r\n            })\r\n            .catch(error => {\r\n                console.error('Failed to fetch conversation:', error);\r\n            });\r\n    };\r\n\r\n    // Function to fetch all conversations for a specific user.\r\n    const fetchConversations = (userId) => {\r\n        fetch(`http://localhost:8888/api/conversations/user/${userId}`)\r\n            .then(response => response.json())\r\n            .then(data => {\r\n                setConversations(data);\r\n            })\r\n            .catch(error => {\r\n                console.error('Failed to fetch conversations:', error);\r\n                setConversations([]);  // Reset to empty array on error to clear previous state.\r\n            });\r\n    };\r\n\r\n    // Render the provider with its value containing state and functions that can be accessed by consumer components.\r\n    return (\r\n        <MessageContext.Provider value={{\r\n            currentConversation,\r\n            fetchConversation,\r\n            sendMessage,\r\n            setCurrentConversation,\r\n            conversations,  // Make conversations list available.\r\n            fetchConversations,  // Make method to fetch conversations available.\r\n            setConversations  // Make setter function for conversations available.\r\n        }}>\r\n            {children}  \r\n        </MessageContext.Provider>  // Render children within the provider to allow access to the context.\r\n    );\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}